package com.one.ourwiki.initialData;

import com.one.ourwiki.domain.Post;
import com.one.ourwiki.repository.PostRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class InitialData implements ApplicationRunner {

    private final PostRepository postRepository;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        Post post = new Post("java string.split의 기능",
                "예비 프로그래머",
                "JAVA",
                2
                , "매개변수 separator Optional 원본 문자열을항해 화이팅 끊어야 할 부분을 나타내는 문자열을 나타냅니다. 실제 문자열이나 정규표현식을 받을 수 있습니다. 문자열 유형의 separator가 두 글자 이상일 경우 그 부분 문자열 전체가 일치해야 끊어집니다. separator가 생략되거나 str에 등장하지 않을 경우, 반환되는 배열은 원본 문자열을 유일한 원소로 가집니다. separator가 빈 문자열일 경우 str의 각각의 문자가 배열의 원소 하나씩으로 변환됩니다. limit Optional 끊어진 문자열의 최대 개수를 나타내는 정수입니다. 이 매개변수를 전달하면 split() 메서드는 주어진 separator가 등장할 때마다 문자열을 끊지만 배열의 원소가 limit개가 되면 멈춥니다. 지정된 한계에 도달하기 전에 문자열의 끝까지 탐색했을 경우 limit개 미만의 원소가 있을 수도 있습니다. 남은 문자열은 새로운 배열에 포함되지 않습니다. 반환값 주어진 문자열을 separator마다 끊은 부분 문자열을 담은 Array. 설명 문자열에서 separator가 등장하면 해당 부분은 삭제되고 남은 문자열이 배열로 반환됩니다. separator가 등장하지 않거나 생략되었을 경우 배열은 원본 문자열을 유일한 원소로 가집니다. separator가 빈 문자열일 경우, str은 문자열의 모든 문자를 원소로 가지는 배열로 변환됩니다. separator가 원본 문자열의 처음이나 끝에 등장할 경우 반환되는 배열도 빈 문자열로 시작하거나 끝납니다. 그러므로 원본 문자열에 separator 하나만이 포함되어 있을 경우 빈 문자열 두 개를 원소로 가지는 배열이 반환됩니다. separator가 포획 괄호를 포함하는 정규표현식일 경우, separator가 일치할 때마다 포획 괄호의 (정의되지 않은 경우도 포함한) 결과가 배열의 해당 위치에 포함됩니다.",
                "123456");

        Post post2 = new Post("항해 수료생",
                "비전공자 프로그래머",
                "기타",
                10,
                " 그때 당시, '개발자가 되고싶다.' 라는 생각은 굉장히 막연했다. 전공자도 아니었고, 제대로된 커리큘럼에 따라 교육을 받지도, 받을 수도 없는 상황이였다. 그저 하루하루 생각만 하고, 시중에 있는 여러 강의를 보고 코딩을 따라하는 나날의 연속이였다. 이 생각의 시작은 아마 2018년 정도였을 것이다. 그때부터 계속 '막연하게, 막연하게' 보내다 보니 정말 이렇게 해서는 안되겠다. 라는 생각이 번뜩 들었다. '계기'가 필요했다. 이 막연함의 연속을 끊을 계기가. 그래서 항해99를 선택했다. 나름 독학은 했지만 나의 객관적인 학습상태를 알 수 없었고, 시중에 좋다고 하는 강의를 닥치는대로 수강하다보니 단계적인 학습을 할 수 없었다. 내가 하고 있는 것이 잘 하고 있는 것인지?, 이렇게 해도 되는건지?, 제대로 정리된 교육과정이란 어떤 것일까? 라는 물음을 스스로에게 계속 던지고 있었다. 이러한 물음에 항해99가 답이 될 수 있지 않을까? 하는 생각이 들었고 바로 2기에 지원했던 것 같다. 정말 제대로 할 수 있을 것 같았고, 그래서 직장도 휴직을 했었다. 내가 배우고자 했던 프론트엔드(리액트)의 커리큘럼도 탄탄해보였고, 협업 프로젝트가 많다는 점, 그리고 몰입할 수 있는 환경 (주 6일 / 09시 ~ 21시)이 이목을 끌었던 것 같다. 나혼자가 아니라 나와 함께 하는 사람들도 같이 몰입할 수 있는 환경에서 공부를 할 수 있다는 것이 굉장히 좋다고 생각했기 때문이다. 그리고 마지막은 타 부트캠프에 비해 합리적인 가격이었다. 그 당시에는 마냥 좋아보였고, 지금와서 다시 생각해보니 확실히 좋다고 말할 수 있다. 사전 준비 준비는 하면 할 수록 좋다. 나는 항해99에 오기전부터 리액트를 6개월 정도 독학하고 있었고, 기본적인 html, css, js를 어느정도 만져본 상태로 항해에 왔다. 이것을 준비하지 않고 온다고해서 불가능한 것은 아니다. 실제로 항해99에서 코딩을 처음 경험하고도 수료하신 크루들이 많으니까. 다만, (프론트엔드 기준으로) html, css, js, react 는 어느정도 다뤄보고 오는 것이 좋다. 미리 다뤄보고 오면 항해에서 더 깊은 곳으로 들어갈 수 있도록 등을 팍팍 밀어준다",
                "123456");
        Post post3 = new Post("Spring을 사용하는 이유",
                "Spring 프로그래머",
                "Spring",
                230,
                " 스프링 프레임워크 스프링 프레임워크는 프로그램의 기본 흐름이나 구조를 정하고, 모두가 스프링 프레임워크라는 구조에 개발자 개개인이 코드를 추가하는 방식으로 개발하는 것입니다. - 스프링 프레임워크의 장점 1) 개발에 필요한 구조를 이미 코드로 만들어 놓았기 때문에 실력이 부족한 개발자라 하더라도 반쯤 완성한 상태에서 필요한 부분을 조립하는 형태의 개발이 가능합니다. 2) 어느정도 품질이 보장되어있고, 구축되어있는 구조에 코드를 넣어 개발하는 형태이기 때문에 개발시간의 단축또한 장점입니다. - 스프링 프레임워크의 단점 1) 구조가 있기 때문에 프레임워크에 있는 코드를 습득하고 이해하는데 오랜 시간이 걸립니다. 2) 스프링 프레임워크의 형식에 맞추어져 있기 때문에 자유롭고 유연하게 개발하는데에 한계가 있습니다. 3. 스프링 프레임워크의 특징 - 의존성 주입 의존성(Dependency)이란 하나의 객체가 다른 객체 없이 제대로 된 역할을 할 수 없음을 의미합니다. 주입(Injection)은 말 그대로 외부에서 밀어넣는 것을 의미합니다. 합쳐서, 한 객체가 필요한 객체를 외부에서 밀어넣는 것을 의존성 주입이라고 합니다. - 의존성 주입을 사용하는 이유? 어떠한 객체를 필요로 하는 한 객체는 능동적으로 찾는 것 보다 누군가가 알아서 해주는 것이 더 편리할 것입니다. 다시말해 의존성 주입을 받는 객체는 주입을 받는 입장에서 누군가가 알아서 해 준다는 건 어떤 객체든 신경 쓸 필요가 없는 것 입니다. 이는 주입을 받아야 할 객체에게 편리함을 가져다 줍니다. 이러한 편리함은 곧 개발자에게 연관됩니다. - AOP(관점 지향 프로그래밍) 좋은 개발환경의 중요 원칙은 개발자가 비즈니스 로직에만 집중할 수 있게 하는 것 입니다. 그 중 하나는 반복되는 코드의 제거인데, 대부분의 시스템이 공통으로 가지고 있는 보안이나 로그, 트랜잭션과 같이 비즈니스 로직은 아니지만, 반드시 처리가 필요한 부분을 스프링에서는 횡단 관심사(cross-concern)이라고 합니다. AOP는 이러한 횡단 관심사를 모듈로 분리하는 프로그래밍의 패러다임입니다. 스프링은 AOP를 AspectJ의 문법을 통해 작성할 수 있는데, 이를 통해 개발자는 핵심 비즈니스 로직에만 집중해서 코드를 개발할 수 있게 되었고, 프로젝트마다 다른 관심사를 적용할 때 코드의 수정을 최소화시킬 수 있었으며, 유지보수가 수월한 코드를 구성할 수 있습니다. - 트랜잭션 데이터베이스를 이용할 때 트랜잭션 처리에 대해 신경이 많이 쓰이곤 합니다. 스프링은 이런 트랜잭션 관리를 어노테이션 등으로 설정할 수 있기 떄문에 상황에 맞는 코드를 작성할 필요가 없도록 설계되어있습니다.",
                "123456");
        Post post4 = new Post("React를 사용하는 이유",
                "React 프로그래머",
                "React",
                10,
                "그럼, 왜 리액트야? 각각의 프론트앤트 라이브러리 / 프레임워크들은 추구하는 방향과 특징들이 다릅니다. (이 글에서는 리액트를 중심으로 다루기 때문에 타 프론트앤트 라이브러리 / 프레임워크들의 특징은 이 글로 대체하겠습니다.) 그렇다면, 우리가 사용할 리액트의 특징은 무엇이 있을까요? 🛠 Component 단위 작성 컴포넌트는 UI를 구성하는 개별적인 뷰 단위로서, UI를 개발을 레고라고 한다면, 컴포넌트는 블록 역할을 하게 됩니다. 이러한 블록을 조립해 하나의 완성품을 만드는 것과 같습니다. 이러한 특징은 하나의 컴포넌트를 여러 부분에서 사용할 수 있게 해줍니다. 가령, 웹 애플리케이션의 여러 곳에 버튼이 필요하다면, 공통된 하나의 버튼 컴포넌트를 생성하고 그 컴포넌트를 필요한 곳에 가져다 사용하면 되죠. 이러한 특징은 생산성과 유지 보수를 용이하게 합니다. 하나의 요소의 변화가 다른 요소들의 변화에 영향을 미치는 복잡한 로직을 업데이트하는 까다로운 작업에 경우, 컴포넌트의 재사용 기능으로서 보완할 수 있게 됩니다.",
                "123456");

        Post post5 = new Post("ES6과 ES7차이",
                "JS 프로그래머",
                "JavaScript",
                -5,
                "ES6(ES2015) TypeScript의 기반이 되는, 클래스 문법과 모듈 기능 추가, IE9 부터 지원 다음과 같은 문제점들이 사라짐 호이스팅이 사라진 것 같은 효과 함수 단위 스코프에서 블록 단위 스코프로 변경 this를 동적으로 바인딩하지 않는 화살표 함수 모듈화 지원 콜백 지옥에서 구원해줄 Promise Default, Rest 파라미터 해체 할당, Spread 연산자 템플릿 리터럴 브라우저(특히 MS 계열)에서 지원해주지 않는 경우가 많아 바벨(Babel)이라는 트랜스파일러를 써야한다. (이 바벨은 웹브라우저가 아닌 Node.js 위에서 돌아가고… Node.js를 설치하려면 NPM을 알아야하고… 또 모듈화를 사용하려면 웹팩(WebPack)같은 모듈 번들러를 알아야하고…) ES7(ES2016) 제곱 연산자(**) 등장 Array.includes 배열에 해당 요소가 존재하는지 확인하는 메소드 등장 ES8 (ES2017) ES2017에서는 Promise 급의 중대한 변화인 async, await등이 발표됨 async await 객체의 좀더 심화된 메소드가 등장 -Object.keys()에 대응되는 메소드인 Object.values() -Object.keys()와 Object.values()를 합쳐 놓은 Object.entries() 등 문자열 단순 편의기능이 추가: -문자열 앞부분에 공백을 넣어 자리수를 맞춰주는 String.padStart() -문자열 뒷부분에 공백을 넣어 자리수를 맞춰주는 String.padEnd() -매개변수 마지막에 콤마를 붙이는 것 허용",
                "123456");

        Post post6 = new Post("컴퓨터 구조",
                "컴퓨터 프로그래머",
                "Computer Science",
                -2000,
                "컴퓨터 하드웨어는 아주 단순한 저수준의 명령어만을 실행할 수 있습니다. 오직 0, 1로만 이루어진 수 그 명령어가 이루어져 있습니다. 따라서 사용자들이 일반적으로 사용하는 복잡한 응용 프로그램(소프트웨어)은 사실 하드웨어에서 실행되기 위해 번역의 과정을 거칩니다. 높은 수준의 작업을 저수준의 명령어로 번역하는 여러 단계의 과정, 이에 시스템 소프트웨어가 필요합니다. 이러한 소프트웨어들은 계층적으로 구성되는데, 크게 하드웨어와 응용 소프트웨어(프로그램) 사이에는 여러 가지 시스템 소프트웨어가 존재한다고 보면 됩니다. 사용자가 컴퓨터를 켜서 사용하는 프로그램들 = 응용 소프트웨어 응용 소프트웨어가 하드웨어에서 실행되도록 만드는 소프트웨어 = 시스템 소프트웨어 실제 소프트웨어가 실행되는 곳 = 하드웨어",
                "123456");

        postRepository.save(post);
        postRepository.save(post2);
        postRepository.save(post3);
        postRepository.save(post4);
        postRepository.save(post5);
        postRepository.save(post6);
    }
}
